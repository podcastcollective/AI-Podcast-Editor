<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Podcast Editor</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef } = React;

        // Icons
        const UploadIcon = ({className}) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const CheckCircle = ({className}) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
            </svg>
        );

        const AlertCircle = ({className}) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
        );

        const FileAudio = ({className}) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M17.5 22h.5a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <path d="M10 20v-1a2 2 0 1 1 4 0v1a2 2 0 1 1-4 0Z"></path>
                <path d="M6 20v-1a2 2 0 1 0-4 0v1a2 2 0 1 0 4 0Z"></path>
                <path d="M2 19v-3a6 6 0 0 1 12 0v3"></path>
            </svg>
        );

        const Sparkles = ({className}) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"></path>
                <path d="M5 3v4"></path>
                <path d="M19 17v4"></path>
                <path d="M3 5h4"></path>
                <path d="M17 19h4"></path>
            </svg>
        );

        const Download = ({className}) => (
            <svg className={className} width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );

        const API_URL = 'https://ai-podcast-editor-production.up.railway.app';

        const STAGES = [
            { key: 'uploading',    label: 'Uploading audio' },
            { key: 'transcribing', label: 'Transcribing with AssemblyAI' },
            { key: 'analyzing',    label: 'Analysing with Claude AI' },
            { key: 'cutting',      label: 'Applying edits' },
            { key: 'cleanvoice',   label: 'Studio enhancement with Cleanvoice AI' },
            { key: 'done',         label: 'Complete' },
        ];

        function PodcastEditor() {
            const [screen, setScreen] = useState('upload');
            const [file, setFile] = useState(null);
            const [requirements, setRequirements] = useState({
                removeFillerWords: true,
                removeLongPauses: true,
                normalizeAudio: true,
                removeBackgroundNoise: true,
                targetLength: '',
                customInstructions: ''
            });
            const [pipelineStage, setPipelineStage] = useState(null);
            const [pipelineError, setPipelineError] = useState(null);
            const downloadBlobRef = useRef(null);
            const downloadExtRef = useRef('mp3');

            const handleFileUpload = (e) => {
                const uploadedFile = e.target.files[0];
                if (uploadedFile && uploadedFile.type.includes('audio')) {
                    setFile(uploadedFile);
                }
            };

            const runFullPipeline = async () => {
                if (!file) return;
                setScreen('progress');
                setPipelineError(null);
                setPipelineStage('uploading');

                try {
                    // Stage 1: Upload
                    const formData = new FormData();
                    formData.append('file', file);
                    const uploadRes = await fetch(`${API_URL}/api/upload`, { method: 'POST', body: formData });
                    if (!uploadRes.ok) {
                        const err = await uploadRes.json();
                        throw { stage: 'uploading', message: err.error || 'Upload failed' };
                    }
                    const uploadData = await uploadRes.json();
                    const { transcript_id, filename } = uploadData;

                    // Stage 2: Transcribe (poll)
                    setPipelineStage('transcribing');
                    while (true) {
                        await new Promise(r => setTimeout(r, 5000));
                        let statusRes;
                        try { statusRes = await fetch(`${API_URL}/api/transcription-status/${transcript_id}`); }
                        catch { throw { stage: 'transcribing', message: 'Server unreachable — it may be restarting. Please retry.' }; }
                        const statusData = await statusRes.json();
                        if (statusData.status === 'completed') break;
                        if (statusData.status === 'error') {
                            throw { stage: 'transcribing', message: statusData.error || 'Transcription failed' };
                        }
                    }

                    // Stage 3: Claude analysis (with frontend-level retry on overload)
                    setPipelineStage('analyzing');
                    let editDecisions = [];
                    const analysisBody = JSON.stringify({
                        transcript_id,
                        filename,
                        requirements: {
                            removeFillerWords: requirements.removeFillerWords,
                            removeLongPauses: requirements.removeLongPauses,
                            normalizeAudio: requirements.normalizeAudio,
                            removeBackgroundNoise: requirements.removeBackgroundNoise,
                            targetLength: requirements.targetLength
                        },
                        customInstructions: requirements.customInstructions
                    });

                    for (let analysisAttempt = 0; analysisAttempt < 3; analysisAttempt++) {
                        const processRes = await fetch(`${API_URL}/api/process`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: analysisBody
                        });
                        const processData = await processRes.json();
                        if (!processRes.ok) throw { stage: 'analyzing', message: processData.error || 'Analysis failed to start' };
                        const analysisJobId = processData.job_id;
                        if (!analysisJobId) throw { stage: 'analyzing', message: 'No job_id returned' };

                        let retryable = false;
                        while (true) {
                            await new Promise(r => setTimeout(r, 3000));
                            let pollRes;
                            try { pollRes = await fetch(`${API_URL}/api/process-status/${analysisJobId}`); }
                            catch { throw { stage: 'analyzing', message: 'Server unreachable — it may be restarting. Please retry.' }; }
                            if (pollRes.status === 404) throw { stage: 'analyzing', message: 'Server restarted during processing. Please retry.' };
                            const pollData = await pollRes.json();
                            if (pollData.retryable) { retryable = true; break; }
                            if (!pollRes.ok) throw { stage: 'analyzing', message: pollData.error || 'Analysis failed' };
                            if (pollData.success) {
                                editDecisions = pollData.edit_decisions || [];
                                break;
                            }
                        }
                        if (editDecisions.length > 0 || !retryable) break;
                        if (analysisAttempt < 2) {
                            console.log(`Claude API overloaded, frontend retry ${analysisAttempt + 1}/3 in 30s...`);
                            await new Promise(r => setTimeout(r, 30000));
                        }
                    }
                    if (editDecisions.length === 0) throw { stage: 'analyzing', message: 'Claude API overloaded after multiple retries. Please try again later.' };

                    // Stage 4-6: Edit audio pipeline (cutting + cleanvoice + auphonic)
                    setPipelineStage('cutting');
                    const cuts = editDecisions.filter(d => d.start_ms != null && d.end_ms != null);
                    const editRes = await fetch(`${API_URL}/api/edit-audio`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ transcript_id, cuts })
                    });
                    const editData = await editRes.json();
                    if (!editRes.ok) throw { stage: 'cutting', message: editData.error || 'Edit job failed to start' };
                    const editJobId = editData.job_id;
                    downloadExtRef.current = 'mp3';

                    while (true) {
                        await new Promise(r => setTimeout(r, 4000));
                        let statusRes;
                        try { statusRes = await fetch(`${API_URL}/api/edit-audio-status/${editJobId}`); }
                        catch { throw { stage: 'cutting', message: 'Server unreachable — it may be restarting. Please retry.' }; }
                        if (statusRes.status === 404) throw { stage: 'cutting', message: 'Server restarted during processing. Please retry.' };
                        const statusData = await statusRes.json();
                        if (statusData.status === 'cutting')    setPipelineStage('cutting');
                        if (statusData.status === 'cleanvoice') setPipelineStage('cleanvoice');
                        if (statusData.status === 'completed')  break;
                        if (!statusRes.ok) {
                            throw { stage: statusData.failed_step || 'cutting', message: statusData.error || 'Audio processing failed' };
                        }
                    }

                    // Stage 7: Download blob into memory
                    const dlRes = await fetch(`${API_URL}/api/edit-audio-download/${editJobId}`);
                    if (!dlRes.ok) {
                        const err = await dlRes.json();
                        throw { stage: 'done', message: err.error || 'Download failed' };
                    }
                    downloadBlobRef.current = await dlRes.blob();

                    setPipelineStage('done');
                    setScreen('download');

                } catch (err) {
                    console.error('Pipeline error:', err);
                    const message = err.stage ? err.message :
                        (err instanceof TypeError ? 'Server unreachable — it may be restarting. Please retry.' :
                        err.message || 'An unexpected error occurred');
                    setPipelineError({
                        stage: err.stage || pipelineStage || 'uploading',
                        message
                    });
                }
            };

            const handleDownload = () => {
                if (!downloadBlobRef.current) return;
                const url = URL.createObjectURL(downloadBlobRef.current);
                const a = document.createElement('a');
                a.href = url;
                a.download = `edited_podcast.${downloadExtRef.current}`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const resetToUpload = () => {
                setScreen('upload');
                setPipelineStage(null);
                setPipelineError(null);
                setFile(null);
                downloadBlobRef.current = null;
            };

            // --- Render ---

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 flex items-center justify-center p-6">
                    <div className="w-full max-w-2xl">

                        {/* Header */}
                        <div className="text-center mb-8">
                            <div className="flex items-center justify-center gap-3 mb-2">
                                <Sparkles className="text-purple-300" />
                                <h1 className="text-3xl font-bold text-white">AI Podcast Editor</h1>
                            </div>
                        </div>

                        {/* ─── Screen 1: Upload ─── */}
                        {screen === 'upload' && (
                            <div className="bg-white/10 backdrop-blur-lg rounded-2xl border border-white/20 p-8">
                                <h2 className="text-xl font-semibold text-white mb-6">Upload Episode</h2>

                                {/* Drop zone */}
                                <div className="border-2 border-dashed border-purple-400/50 rounded-xl p-8 text-center mb-6 bg-white/5 hover:bg-white/10 transition-all cursor-pointer">
                                    <input type="file" accept="audio/*" onChange={handleFileUpload} className="hidden" id="file-upload" />
                                    <label htmlFor="file-upload" className="cursor-pointer">
                                        <div className="w-12 h-12 mx-auto mb-3 text-purple-300 flex items-center justify-center">
                                            <FileAudio />
                                        </div>
                                        {file ? (
                                            <div className="text-white">
                                                <p className="font-semibold">{file.name}</p>
                                                <p className="text-sm text-purple-200">{(file.size / 1024 / 1024).toFixed(2)} MB</p>
                                            </div>
                                        ) : (
                                            <div>
                                                <p className="text-white font-semibold mb-1">Drop your podcast file here</p>
                                                <p className="text-purple-200 text-sm">or click to browse</p>
                                            </div>
                                        )}
                                    </label>
                                </div>

                                {/* Options grid */}
                                <div className="grid md:grid-cols-2 gap-6 mb-6">
                                    <div>
                                        <h3 className="text-sm font-semibold text-purple-200 uppercase tracking-wide mb-3">Edit Options</h3>
                                        <div className="space-y-3">
                                            {[
                                                { key: 'removeFillerWords', label: 'Remove filler words' },
                                                { key: 'removeLongPauses', label: 'Remove long pauses' },
                                                { key: 'normalizeAudio', label: 'Normalize audio levels' },
                                                { key: 'removeBackgroundNoise', label: 'Remove background noise' },
                                            ].map(opt => (
                                                <label key={opt.key} className="flex items-center gap-3 text-white cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        checked={requirements[opt.key]}
                                                        onChange={e => setRequirements({...requirements, [opt.key]: e.target.checked})}
                                                        className="w-4 h-4 rounded accent-purple-500"
                                                    />
                                                    <span className="text-sm">{opt.label}</span>
                                                </label>
                                            ))}
                                        </div>

                                        <div className="mt-4">
                                            <label className="block text-sm text-purple-200 mb-1">Target length</label>
                                            <input
                                                type="text"
                                                placeholder="e.g., 45 minutes"
                                                value={requirements.targetLength}
                                                onChange={e => setRequirements({...requirements, targetLength: e.target.value})}
                                                className="w-full p-2.5 rounded-lg bg-white/10 border border-white/20 text-white placeholder-purple-300 text-sm"
                                            />
                                        </div>
                                    </div>

                                    <div>
                                        <h3 className="text-sm font-semibold text-purple-200 uppercase tracking-wide mb-3">Custom Instructions</h3>
                                        <textarea
                                            placeholder="e.g., Keep the banter between hosts, remove technical difficulties around 15:30..."
                                            value={requirements.customInstructions}
                                            onChange={e => setRequirements({...requirements, customInstructions: e.target.value})}
                                            className="w-full p-2.5 rounded-lg bg-white/10 border border-white/20 text-white placeholder-purple-300 text-sm h-44 resize-none"
                                        />
                                    </div>
                                </div>

                                <button
                                    onClick={runFullPipeline}
                                    disabled={!file}
                                    className="w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white font-semibold py-4 rounded-xl hover:from-purple-600 hover:to-pink-600 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                                >
                                    <Sparkles className="w-5 h-5" />
                                    Edit Audio
                                </button>
                            </div>
                        )}

                        {/* ─── Screen 2: Progress ─── */}
                        {screen === 'progress' && (
                            <div className="bg-white/10 backdrop-blur-lg rounded-2xl border border-white/20 p-8">
                                <h2 className="text-xl font-semibold text-white mb-6">Editing in progress</h2>

                                <div className="space-y-2">
                                    {STAGES.map((stage, i) => {
                                        const currentIdx = STAGES.findIndex(s => s.key === pipelineStage);
                                        const failedStage = pipelineError && pipelineError.stage === stage.key;
                                        const done = !failedStage && currentIdx > i;
                                        const active = !failedStage && pipelineStage === stage.key && stage.key !== 'done';

                                        let icon, textColor, bgColor;
                                        if (failedStage) {
                                            icon = <AlertCircle className="w-5 h-5 text-red-400" />;
                                            textColor = 'text-red-300';
                                            bgColor = 'bg-red-500/15 border-red-500/40';
                                        } else if (done) {
                                            icon = <CheckCircle className="w-5 h-5 text-green-400" />;
                                            textColor = 'text-green-300';
                                            bgColor = 'bg-green-500/10 border-green-500/30';
                                        } else if (active) {
                                            icon = (
                                                <svg className="w-5 h-5 text-purple-400 animate-spin" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                                    <path d="M21 12a9 9 0 1 1-6.219-8.56" />
                                                </svg>
                                            );
                                            textColor = 'text-white';
                                            bgColor = 'bg-purple-500/15 border-purple-500/40';
                                        } else {
                                            icon = <div className="w-5 h-5 rounded-full border-2 border-white/20" />;
                                            textColor = 'text-white/30';
                                            bgColor = 'bg-white/5 border-white/10';
                                        }

                                        return (
                                            <div key={stage.key} className={`flex items-center gap-3 rounded-lg px-4 py-3 border ${bgColor}`}>
                                                <div className="shrink-0">{icon}</div>
                                                <span className={`font-medium text-sm ${textColor}`}>{stage.label}</span>
                                            </div>
                                        );
                                    })}
                                </div>

                                {/* Error card */}
                                {pipelineError && (
                                    <div className="mt-6 bg-red-500/10 border border-red-500/50 rounded-xl p-5">
                                        <p className="text-red-300 font-semibold text-sm mb-1">
                                            Pipeline stopped at: {pipelineError.stage}
                                        </p>
                                        <p className="text-red-200/70 text-xs font-mono break-all mb-4">
                                            {pipelineError.message}
                                        </p>
                                        <div className="flex gap-3">
                                            <button
                                                onClick={() => { setPipelineError(null); runFullPipeline(); }}
                                                className="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm font-semibold transition-all"
                                            >
                                                Retry from start
                                            </button>
                                            <button
                                                onClick={resetToUpload}
                                                className="bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded-lg text-sm font-semibold transition-all"
                                            >
                                                Back to upload
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* ─── Screen 3: Download ─── */}
                        {screen === 'download' && (
                            <div className="bg-white/10 backdrop-blur-lg rounded-2xl border border-white/20 p-8 text-center">
                                <div className="w-16 h-16 mx-auto mb-4 text-green-400">
                                    <CheckCircle className="w-16 h-16" />
                                </div>
                                <h2 className="text-2xl font-bold text-white mb-2">Your podcast is ready</h2>
                                <p className="text-purple-200 mb-8">All editing stages completed successfully.</p>

                                <button
                                    onClick={handleDownload}
                                    className="bg-gradient-to-r from-green-500 to-emerald-500 text-white font-semibold py-4 px-8 rounded-xl hover:from-green-600 hover:to-emerald-600 transition-all flex items-center justify-center gap-2 mx-auto"
                                >
                                    <Download className="w-5 h-5" />
                                    Download Edited Audio
                                </button>

                                <button
                                    onClick={resetToUpload}
                                    className="mt-4 text-purple-300 hover:text-white text-sm transition-all"
                                >
                                    Edit another episode
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PodcastEditor />);
    </script>
</body>
</html>
